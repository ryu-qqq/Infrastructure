# {{ service_name | upper }} - SQS Queue

Generated by Infrastructure Wizard on {{ generation_time }}

## Overview

SQS queue for {{ service_name }} with {% if fifo_queue %}FIFO ordering{% else %}standard delivery{% endif %}{% if dead_letter_queue %} and dead letter queue{% endif %}.

## Resources Created

- SQS {% if fifo_queue %}FIFO {% endif %}queue
{% if dead_letter_queue %}- Dead letter queue (DLQ){% endif %}
{% if encryption %}- KMS key for encryption{% endif %}
- CloudWatch alarms (depth, age{% if dead_letter_queue %}, DLQ{% endif %})
- SSM parameters (queue URL, ARN{% if dead_letter_queue %}, DLQ URL{% endif %})

## Configuration

- **Queue Type**: {% if fifo_queue %}FIFO (.fifo){% else %}Standard{% endif %}
- **Message Retention**: {{ message_retention }} seconds ({{ (message_retention / 86400) | int }} days)
- **Visibility Timeout**: {{ visibility_timeout }} seconds
- **Long Polling**: 20 seconds
- **Max Message Size**: 256 KB
{% if encryption %}- **Encryption**: KMS (customer-managed key){% else %}- **Encryption**: None{% endif %}
{% if dead_letter_queue %}- **DLQ**: Enabled (max receive count: 3){% else %}- **DLQ**: Disabled{% endif %}
{% if fifo_queue %}- **Content-Based Deduplication**: Enabled
- **Throughput Limit**: Per message group ID{% endif %}

## Security Features

{% if encryption %}- ðŸ”’ KMS encryption with customer-managed keys
{% endif %}- ðŸ” TLS enforcement (HTTPS only)
- ðŸ›¡ï¸ IAM-based access control
{% if dead_letter_queue %}- âš ï¸ Dead letter queue for failed messages
{% endif %}- ðŸ“ CloudWatch alarms for monitoring

## Queue URLs

### Main Queue

```
https://sqs.{{ aws_region }}.amazonaws.com/ACCOUNT_ID/{{ service_name }}-{{ environment }}{% if fifo_queue %}.fifo{% endif %}
```

{% if dead_letter_queue %}
### Dead Letter Queue

```
https://sqs.{{ aws_region }}.amazonaws.com/ACCOUNT_ID/{{ service_name }}-dlq-{{ environment }}{% if fifo_queue %}.fifo{% endif %}
```
{% endif %}

### Retrieve from SSM

```bash
QUEUE_URL=$(aws ssm get-parameter --name "/{{ service_name }}/{{ environment }}/sqs/queue-url" --query "Parameter.Value" --output text)
{% if dead_letter_queue %}DLQ_URL=$(aws ssm get-parameter --name "/{{ service_name }}/{{ environment }}/sqs/dlq-url" --query "Parameter.Value" --output text)
{% endif %}
echo "Queue URL: $QUEUE_URL"
```

## Usage Examples

### AWS CLI

```bash
# Send message
{% if fifo_queue %}aws sqs send-message \
  --queue-url "$QUEUE_URL" \
  --message-body "Hello World" \
  --message-group-id "group1" \
  --message-deduplication-id "$(uuidgen)"
{% else %}aws sqs send-message \
  --queue-url "$QUEUE_URL" \
  --message-body "Hello World"
{% endif %}

# Receive messages
aws sqs receive-message \
  --queue-url "$QUEUE_URL" \
  --max-number-of-messages 10 \
  --wait-time-seconds 20

# Delete message
aws sqs delete-message \
  --queue-url "$QUEUE_URL" \
  --receipt-handle "RECEIPT_HANDLE"

# Purge queue (delete all messages)
aws sqs purge-queue --queue-url "$QUEUE_URL"
```

### Node.js (AWS SDK v3)

```javascript
const { SQSClient, SendMessageCommand, ReceiveMessageCommand, DeleteMessageCommand } = require('@aws-sdk/client-sqs');

const client = new SQSClient({ region: '{{ aws_region }}' });
const queueUrl = process.env.QUEUE_URL;

// Send message
async function sendMessage(body) {
  const command = new SendMessageCommand({
    QueueUrl: queueUrl,
    MessageBody: JSON.stringify(body),
{% if fifo_queue %}    MessageGroupId: 'group1',
    MessageDeduplicationId: Date.now().toString(),
{% endif %}  });

  const response = await client.send(command);
  console.log('Message sent:', response.MessageId);
}

// Receive messages
async function receiveMessages() {
  const command = new ReceiveMessageCommand({
    QueueUrl: queueUrl,
    MaxNumberOfMessages: 10,
    WaitTimeSeconds: 20,
  });

  const response = await client.send(command);
  return response.Messages || [];
}

// Delete message
async function deleteMessage(receiptHandle) {
  const command = new DeleteMessageCommand({
    QueueUrl: queueUrl,
    ReceiptHandle: receiptHandle,
  });

  await client.send(command);
}

// Process messages
async function processMessages() {
  const messages = await receiveMessages();

  for (const message of messages) {
    try {
      const body = JSON.parse(message.Body);
      console.log('Processing:', body);

      // Your processing logic here

      await deleteMessage(message.ReceiptHandle);
    } catch (error) {
      console.error('Error processing message:', error);
    }
  }
}
```

### Python (boto3)

```python
import boto3
import json
import os
{% if fifo_queue %}import uuid
{% endif %}

sqs = boto3.client('sqs', region_name='{{ aws_region }}')
queue_url = os.getenv('QUEUE_URL')

# Send message
def send_message(body):
    response = sqs.send_message(
        QueueUrl=queue_url,
        MessageBody=json.dumps(body),
{% if fifo_queue %}        MessageGroupId='group1',
        MessageDeduplicationId=str(uuid.uuid4()),
{% endif %}    )
    print(f"Message sent: {response['MessageId']}")

# Receive messages
def receive_messages():
    response = sqs.receive_message(
        QueueUrl=queue_url,
        MaxNumberOfMessages=10,
        WaitTimeSeconds=20,
    )
    return response.get('Messages', [])

# Delete message
def delete_message(receipt_handle):
    sqs.delete_message(
        QueueUrl=queue_url,
        ReceiptHandle=receipt_handle,
    )

# Process messages
def process_messages():
    messages = receive_messages()

    for message in messages:
        try:
            body = json.loads(message['Body'])
            print(f"Processing: {body}")

            # Your processing logic here

            delete_message(message['ReceiptHandle'])
        except Exception as e:
            print(f"Error processing message: {e}")
```

### Go (AWS SDK v2)

```go
import (
    "context"
    "encoding/json"
    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/service/sqs"
{% if fifo_queue %}    "github.com/google/uuid"
{% endif %})

client := sqs.NewFromConfig(cfg)
queueURL := os.Getenv("QUEUE_URL")

// Send message
func sendMessage(ctx context.Context, body interface{}) error {
    data, _ := json.Marshal(body)

    input := &sqs.SendMessageInput{
        QueueUrl:    aws.String(queueURL),
        MessageBody: aws.String(string(data)),
{% if fifo_queue %}        MessageGroupId:         aws.String("group1"),
        MessageDeduplicationId: aws.String(uuid.New().String()),
{% endif %}    }

    result, err := client.SendMessage(ctx, input)
    if err != nil {
        return err
    }

    fmt.Printf("Message sent: %s\n", *result.MessageId)
    return nil
}

// Receive messages
func receiveMessages(ctx context.Context) ([]types.Message, error) {
    input := &sqs.ReceiveMessageInput{
        QueueUrl:            aws.String(queueURL),
        MaxNumberOfMessages: 10,
        WaitTimeSeconds:     20,
    }

    result, err := client.ReceiveMessage(ctx, input)
    if err != nil {
        return nil, err
    }

    return result.Messages, nil
}

// Delete message
func deleteMessage(ctx context.Context, receiptHandle string) error {
    input := &sqs.DeleteMessageInput{
        QueueUrl:      aws.String(queueURL),
        ReceiptHandle: aws.String(receiptHandle),
    }

    _, err := client.DeleteMessage(ctx, input)
    return err
}
```

## Monitoring

### CloudWatch Metrics

```bash
# Queue depth
aws cloudwatch get-metric-statistics \
  --namespace AWS/SQS \
  --dimensions Name=QueueName,Value={{ service_name }}-{{ environment }}{% if fifo_queue %}.fifo{% endif %} \
  --metric-name ApproximateNumberOfMessagesVisible \
  --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
  --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
  --period 300 \
  --statistics Average

# Message age
aws cloudwatch get-metric-statistics \
  --namespace AWS/SQS \
  --dimensions Name=QueueName,Value={{ service_name }}-{{ environment }}{% if fifo_queue %}.fifo{% endif %} \
  --metric-name ApproximateAgeOfOldestMessage \
  --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
  --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
  --period 300 \
  --statistics Maximum
```

### CloudWatch Alarms

- **Queue Depth**: Alarm when > 1000 messages for 10 minutes
- **Message Age**: Alarm when oldest message > 1 hour
{% if dead_letter_queue %}- **DLQ Depth**: Alarm when any message appears in DLQ{% endif %}

## Best Practices

### Message Processing

1. **Use Long Polling**: Already configured (20 seconds)
2. **Handle Idempotency**: Process messages idempotently
3. **Visibility Timeout**: Set based on processing time (currently {{ visibility_timeout }}s)
4. **Delete After Processing**: Always delete successfully processed messages

{% if fifo_queue %}
### FIFO Queue Specifics

1. **Message Group ID**: Group related messages for ordered processing
2. **Deduplication**: Content-based deduplication is enabled
3. **Throughput**: Per message group ID (300 msgs/sec per group)
4. **Ordering**: Strict ordering within message groups
{% endif %}

### Error Handling

1. **Retry Logic**: Implement exponential backoff
2. **DLQ Monitoring**: {% if dead_letter_queue %}Monitor DLQ for failed messages{% else %}Consider enabling DLQ{% endif %}
3. **Logging**: Log all processing errors
4. **Dead Letter Analysis**: Regularly review and reprocess DLQ messages

## Troubleshooting

### High Queue Depth

1. Scale up consumers
2. Optimize message processing
3. Check for processing errors

### Messages in DLQ

{% if dead_letter_queue %}
```bash
# Check DLQ depth
aws sqs get-queue-attributes \
  --queue-url "$DLQ_URL" \
  --attribute-names ApproximateNumberOfMessages

# Receive DLQ messages
aws sqs receive-message --queue-url "$DLQ_URL"

# Reprocess DLQ messages
aws sqs send-message-batch \
  --queue-url "$QUEUE_URL" \
  --entries file://messages.json
```
{% else %}
DLQ is not enabled. Enable with `dead_letter_queue: true` in configuration.
{% endif %}

## Deployment

1. Initialize Terraform: `terraform init`
2. Plan changes: `terraform plan`
3. Apply: `terraform apply`

---

ðŸ¤– Generated with Infrastructure Wizard
