name: Terraform Apply and Deploy

on:
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - 'docker/**'
      - '.github/workflows/terraform-*.yml'

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: atlantis

jobs:
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    outputs:
      ecr_registry: ${{ steps.registry.outputs.registry }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Clean up orphaned resources
        run: |
          echo "üßπ Checking for orphaned resources..."

          # Clean up IAM roles
          echo "üë§ Checking for orphaned IAM roles..."
          for role in atlantis-ecs-task-execution-prod atlantis-ecs-task-prod; do
            if aws iam get-role --role-name $role &>/dev/null; then
              echo "üóëÔ∏è  Deleting IAM role: $role"
              # Delete inline policies
              aws iam list-role-policies --role-name $role --query 'PolicyNames[*]' --output text 2>/dev/null | tr '\t' '\n' | while read policy; do
                [ ! -z "$policy" ] && aws iam delete-role-policy --role-name $role --policy-name "$policy" 2>/dev/null || true
              done
              # Detach managed policies
              aws iam list-attached-role-policies --role-name $role --query 'AttachedPolicies[*].PolicyArn' --output text 2>/dev/null | tr '\t' '\n' | while read arn; do
                [ ! -z "$arn" ] && aws iam detach-role-policy --role-name $role --policy-arn "$arn" 2>/dev/null || true
              done
              # Delete role
              aws iam delete-role --role-name $role 2>/dev/null && echo "‚úì Role $role deleted" || echo "! Failed to delete $role"
            else
              echo "‚úì No orphaned role: $role"
            fi
          done

          # Clean up CloudWatch Log Group
          echo "üìä Checking for orphaned CloudWatch Log Group..."
          if aws logs describe-log-groups --log-group-name-prefix /ecs/atlantis-prod --region ${{ env.AWS_REGION }} --query 'logGroups[0]' --output text &>/dev/null; then
            echo "üóëÔ∏è  Deleting CloudWatch Log Group..."
            aws logs delete-log-group --log-group-name /ecs/atlantis-prod --region ${{ env.AWS_REGION }} 2>/dev/null && echo "‚úì Log group deleted" || echo "! Failed to delete log group"
          else
            echo "‚úì No orphaned log group"
          fi

          # Clean up ECS Cluster
          echo "üéØ Checking for orphaned ECS Cluster..."
          if aws ecs describe-clusters --clusters atlantis-prod --region ${{ env.AWS_REGION }} --query 'clusters[0].status' --output text 2>/dev/null | grep -q "ACTIVE"; then
            echo "üóëÔ∏è  Deleting ECS Cluster..."
            aws ecs delete-cluster --cluster atlantis-prod --region ${{ env.AWS_REGION }} 2>/dev/null && echo "‚úì Cluster deleted" || echo "! Failed to delete cluster"
          else
            echo "‚úì No active ECS cluster"
          fi

          # Clean up ECR repository
          echo "üì¶ Checking for orphaned ECR repository..."
          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} &>/dev/null; then
            echo "üóëÔ∏è  Deleting orphaned ECR repository..."
            aws ecr delete-repository --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} --force
            echo "‚úì ECR repository deleted"
          else
            echo "‚úì No orphaned ECR repository"
          fi

          # Clean up KMS resources
          echo "üîê Checking for orphaned KMS resources..."
          ALIAS_NAME="alias/ecr-atlantis"

          TARGET_KEY_ID=$(aws kms list-aliases --region ${{ env.AWS_REGION }} \
            --query "Aliases[?AliasName=='$ALIAS_NAME'].TargetKeyId" \
            --output text 2>/dev/null || echo "")

          if [ ! -z "$TARGET_KEY_ID" ]; then
            echo "üóëÔ∏è  Deleting KMS alias..."
            aws kms delete-alias --alias-name $ALIAS_NAME --region ${{ env.AWS_REGION }}

            echo "üóëÔ∏è  Scheduling KMS key for deletion (7 days)..."
            aws kms schedule-key-deletion --key-id $TARGET_KEY_ID \
              --pending-window-in-days 7 --region ${{ env.AWS_REGION }}

            echo "‚úì KMS resources cleaned up"
          else
            echo "‚úì No orphaned KMS resources"
          fi

          echo "‚úÖ Cleanup complete"

      - name: Terraform Init
        working-directory: terraform/atlantis
        run: terraform init

      - name: Terraform Apply
        working-directory: terraform/atlantis
        run: terraform apply -auto-approve

      - name: Get ECR Registry
        id: registry
        run: |
          REGISTRY=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "ECR Registry: ${REGISTRY}"

  build-and-push:
    name: Build and Push Docker Image
    needs: terraform-apply
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate Image Tags
        id: meta
        run: |
          # Git commit SHA (short)
          GIT_SHA=$(git rev-parse --short HEAD)

          # Timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)

          # ECR registry from previous job
          REGISTRY=${{ needs.terraform-apply.outputs.ecr_registry }}

          # Generate tags
          TAGS="${REGISTRY}/${{ env.ECR_REPOSITORY }}:${GIT_SHA}"
          TAGS="${TAGS},${REGISTRY}/${{ env.ECR_REPOSITORY }}:latest"
          TAGS="${TAGS},${REGISTRY}/${{ env.ECR_REPOSITORY }}:${TIMESTAMP}"

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "git_sha=${GIT_SHA}" >> $GITHUB_OUTPUT

          echo "Generated tags:"
          echo "${TAGS}" | tr ',' '\n'

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=${{ github.event.head_commit.timestamp }}
            VERSION=${{ steps.meta.outputs.git_sha }}

      - name: Image Scan Results
        run: |
          echo "üîç Waiting for ECR image scan to complete..."
          sleep 30

          # Get scan findings
          aws ecr describe-image-scan-findings \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=${{ steps.meta.outputs.git_sha }} \
            --region ${{ env.AWS_REGION }} \
            --output table || echo "Scan still in progress..."

      - name: Deployment Summary
        run: |
          cat << EOF
          ‚úÖ Deployment Complete!

          üì¶ Repository: ${{ env.ECR_REPOSITORY }}
          üè∑Ô∏è  Tags:
             - ${{ steps.meta.outputs.git_sha }} (git SHA)
             - latest
             - $(date +%Y%m%d-%H%M%S) (timestamp)

          üîó ECR URI: ${{ needs.terraform-apply.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}

          üìã Next Steps:
          1. Review ECR scan results in AWS Console
          2. Update deployment manifests with new image tag
          3. Deploy to target environment
          EOF
