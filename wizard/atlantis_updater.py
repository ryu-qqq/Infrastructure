"""
Atlantis Configuration Updater Module

Handles automatic updates to atlantis.yaml for new services.
"""

import re
from pathlib import Path
from datetime import datetime
from typing import Optional

import yaml
from rich.console import Console

console = Console()


class AtlantisUpdater:
    """Update atlantis.yaml with new service projects."""

    # Section markers
    SECTION_START = "# 4. Application Services"
    SECTION_END = "# END OF WIZARD AUTO-MANAGED SECTION"
    LAST_UPDATED_PREFIX = "# Last updated:"

    def __init__(self, atlantis_yaml_path: Path):
        """
        Initialize Atlantis updater.

        Args:
            atlantis_yaml_path: Path to atlantis.yaml file
        """
        self.atlantis_yaml_path = atlantis_yaml_path

        if not self.atlantis_yaml_path.exists():
            raise FileNotFoundError(f"atlantis.yaml not found: {atlantis_yaml_path}")

    def read_atlantis_config(self) -> str:
        """
        Read atlantis.yaml content.

        Returns:
            File content as string
        """
        with open(self.atlantis_yaml_path, 'r') as f:
            return f.read()

    def write_atlantis_config(self, content: str) -> None:
        """
        Write updated content to atlantis.yaml.

        Args:
            content: Updated file content
        """
        with open(self.atlantis_yaml_path, 'w') as f:
            f.write(content)

    def check_project_exists(self, content: str, project_name: str) -> bool:
        """
        Check if project already exists in atlantis.yaml.

        Args:
            content: File content
            project_name: Project name to check

        Returns:
            True if project already exists
        """
        pattern = f"- name: {project_name}"
        return pattern in content

    def find_auto_managed_section(self, content: str) -> tuple[int, int]:
        """
        Find the auto-managed section boundaries.

        Args:
            content: File content

        Returns:
            Tuple of (section_start_pos, section_end_pos)

        Raises:
            ValueError: If section markers not found
        """
        start_pos = content.find(self.SECTION_START)
        end_pos = content.find(self.SECTION_END)

        if start_pos == -1:
            raise ValueError(f"Section start marker not found: {self.SECTION_START}")

        if end_pos == -1:
            raise ValueError(f"Section end marker not found: {self.SECTION_END}")

        if end_pos <= start_pos:
            raise ValueError("Section end marker appears before start marker")

        return start_pos, end_pos

    def update_last_updated_date(self, content: str) -> str:
        """
        Update the "Last updated" date in the auto-managed section.

        Args:
            content: File content

        Returns:
            Updated content with new date
        """
        today = datetime.now().strftime('%Y-%m-%d')
        pattern = rf"{self.LAST_UPDATED_PREFIX} \d{{4}}-\d{{2}}-\d{{2}}"
        replacement = f"{self.LAST_UPDATED_PREFIX} {today}"

        return re.sub(pattern, replacement, content)

    def generate_project_config(
        self,
        service_name: str,
        service_dir: str,
        environment: str = "prod"
    ) -> str:
        """
        Generate Atlantis project configuration for a service.

        Args:
            service_name: Service name
            service_dir: Service directory path (relative to repo root)
            environment: Environment name

        Returns:
            Formatted project configuration as YAML text
        """
        today = datetime.now().strftime('%Y-%m-%d')

        # Format service name for comment (uppercase with hyphens)
        service_upper = service_name.upper()

        config = f"""
  # {service_upper} - Generated by wizard on {today}
  - name: {service_name}-{environment}
    dir: {service_dir}
    workspace: default
    autoplan:
      when_modified: ["*.tf", "*.tfvars"]
      enabled: true
    apply_requirements: ["approved", "mergeable"]
    workflow: default
"""
        return config

    def add_service(
        self,
        service_name: str,
        service_dir: str,
        environment: str = "prod",
        dry_run: bool = False
    ) -> bool:
        """
        Add a new service to atlantis.yaml.

        Args:
            service_name: Service name
            service_dir: Service directory (e.g., 'terraform/services/api-server')
            environment: Environment name
            dry_run: If True, don't write changes

        Returns:
            True if service was added, False if already exists
        """
        console.print(f"\n[bold]üîß atlantis.yaml ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë...[/bold]")

        # Read current content
        content = self.read_atlantis_config()

        # Check if project already exists
        project_name = f"{service_name}-{environment}"
        if self.check_project_exists(content, project_name):
            console.print(f"[yellow]‚ö†Ô∏è  ÌîÑÎ°úÏ†ùÌä∏Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§: {project_name}[/yellow]")
            return False

        # Find auto-managed section
        try:
            section_start, section_end = self.find_auto_managed_section(content)
        except ValueError as e:
            console.print(f"[red]‚ùå Ïò§Î•ò: {str(e)}[/red]")
            console.print("[yellow]atlantis.yaml Íµ¨Ï°∞Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî[/yellow]")
            raise

        # Generate project configuration
        project_config = self.generate_project_config(service_name, service_dir, environment)

        # Insert before section end marker
        # Find the exact line with section end marker
        end_marker_line_start = content.rfind('\n', 0, section_end)
        if end_marker_line_start == -1:
            end_marker_line_start = 0

        # Insert new project config
        new_content = (
            content[:end_marker_line_start] +
            '\n' + project_config + '\n' +
            content[end_marker_line_start:]
        )

        # Update last updated date
        new_content = self.update_last_updated_date(new_content)

        # Write changes
        if not dry_run:
            self.write_atlantis_config(new_content)
            console.print(f"[green]‚úÖ atlantis.yaml ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å[/green]")
            console.print(f"   ‚Üí ÌîÑÎ°úÏ†ùÌä∏ Ï∂îÍ∞Ä: {project_name}")
            console.print(f"   ‚Üí ÎîîÎ†âÌÜ†Î¶¨: {service_dir}")
        else:
            console.print(f"[yellow]üîç Dry-run Î™®Îìú: atlantis.yamlÏùÑ ÏóÖÎç∞Ïù¥Ìä∏ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§[/yellow]")
            console.print(f"\nÏ∂îÍ∞ÄÎê† ÌîÑÎ°úÏ†ùÌä∏ ÏÑ§Ï†ï:")
            console.print(project_config)

        return True

    def validate_atlantis_yaml(self) -> bool:
        """
        Validate atlantis.yaml syntax.

        Returns:
            True if valid YAML syntax

        Raises:
            yaml.YAMLError: If invalid YAML
        """
        content = self.read_atlantis_config()

        try:
            yaml.safe_load(content)
            return True
        except yaml.YAMLError as e:
            console.print(f"[red]‚ùå atlantis.yaml Íµ¨Î¨∏ Ïò§Î•ò:[/red]")
            console.print(f"[red]{str(e)}[/red]")
            raise
